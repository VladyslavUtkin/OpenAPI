# Neo4j

Neo4j є провідною в світі графічної базою даних з відкритим вихідним кодом, яка розроблена з використанням технології Java. Вона легко масштабується і не містить схем (NoSQL).

![](../src/image/neo4j.png)


## Що таке база даних графів?

*Граф* являє собою графічне представлення набору об'єктів, де деякі пари об'єктів пов'язані посиланнями. Він складається з двох елементів - вузлів (вершин) і відношень (ребер).

*База даних графів* - це база даних, яка використовується для моделювання даних в формі графів. Тут вузли графа зображують сутності, в той час як відношення зображують асоціацію цих вузлів.

## Чи є сенс використовувати граф бази даних?

На сьогодні велика частина даних існує в формі відношень між різними об'єктами, і частіше за все відношення між даними є більш цінними, ніж самі дані.
Реляційні бази даних зберігають високо структуровані дані, в яких є кілька записів, де зберігаються дані одного і того ж типу, тому вони можуть використовуватися для зберігання структурованих даних і не зберігають зв'язку між даними. На відміну від інших баз даних, графові бази даних зберігають відношення і з'єднання як першокласні об'єкти.
Моделі даних для графових баз даних простіші в порівнянні з іншими базами даних, і їх можна використовувати з системами OLTP(Online Transaction Processing). Вони надають такі функції, як цілісність транзакцій і експлуатаційну доступність.

## Переваги Neo4j

* Гнучка модель даних - Neo4j надає гнучку просту і разом з тим потужну модель даних, яку можна легко змінювати в залежності від додатків і галузей.

* Аналіз в реальному часі - Neo4j надає результати на основі даних в реальному часі.

* Висока доступність - Neo4j доступний для великих корпоративних додатків реального часу з транзакційними гарантіями.

* Пов'язані і напівструктуровані дані. Використовуючи Neo4j, ви можете легко представляти пов'язані і напівструктуровані дані.

* Простий пошук - Використовуючи Neo4j, ви можете не тільки уявляти, але і легко витягувати пов'язані дані швидше в порівнянні з іншими базами даних.

* Мова запитів Cypher - Neo4j надає декларативну мову запитів для візуального представлення графіка з використанням синтаксису ascii-art. Команди цієї мови в легкому для читання форматі і дуже прості в освоєнні.

* Ні об'єднанням - використовуючи Neo4j, він НЕ вимагає складних об'єднань для вилучення пов'язаних між собою даних, оскільки дуже легко отримати відомості про сусідній вузол або взаємозв'язок вузлів без об'єднань або індексів.

## Недоліки Neo4j

* Відсутність повноцінного горизонтального масштабування.

* Погано пристосований для розміщення на декількох машинах.

* Для повноцінного видалення доводиться перезапускати сервер.

* Neo4j використовує Apache Lucene, який обробляє всі дані як текст. Це робить чисто цілочисельні запити даних набагато повільніше, ніж вони повинні бути.

* Neo4j не має вбудованого управління користувачами. Вся безпека повинна бути забезпечена на рівні додатку.

## Особливості Neo4j

*Модель даних* (гнучка схема) - Neo4j слідує моделі даних, що називається моделлю графа власних властивостей. Тут граф містить вузли (сутності), і ці вузли пов'язані один з одним (зображені відношеннями). Вузли і відношення зберігають дані в парах ключ-значення, відомих як властивості.
У Neo4j немає необхідності слідувати фіксованою схемою. Ви можете додати або видалити властивості згідно з вимогою. Це також забезпечує обмеження схеми.

*Властивості ACID* - Neo4j підтримує повні правила ACID (атомарность, узгодженість, ізоляція і довговічність).

*Масштабованість і надійність* - ви можете масштабувати базу даних, збільшуючи кількість операцій читання / запису і обсяг, не впливаючи на швидкість обробки запитів і цілісність даних. Neo4j також забезпечує підтримку реплікації для забезпечення безпеки і надійності даних.

*Cypher Query Language* - Neo4j надає потужну декларативну мову запитів, відому як Cypher. Вона використовує ASCII-арт для зображення графіків. Cypher простий в освоєнні і може бути використаний для створення і вилучення відношень між даними без використання складних запитів, таких як Joins.

*Вбудований веб-додаток* - Neo4j надає вбудований веб-додаток Neo4j Browser. Використовуючи це, ви можете створювати і запитувати дані графіка.

*Драйвери* - Neo4j може працювати з :

- REST API для роботи з такими мовами програмування, як Java, Spring, Scala та інші.

- Java Script для роботи з користувача інтерфейсами MVC, такими як Node JS.

- підтримує два види Java API: Cypher API і Native Java API для розробки додатків Java. Також є можливість працювати з іншими базами даних, такими як MongoDB, Cassandra та інші.

*Індексування* - Neo4j підтримує Індекси за допомогою Apache Lucence.

## Neo4j - модель даних
#### Модель данных Neo4j Property Graph

Neo4j Graph Database використовує модель графа властивостей для зберігання і управління своїми даними. Нижче наведені ключові особливості моделі графа властивостей :

1. Модель представляє дані у вузлах, відношеннях і властивостях

2. Властивості є парами ключ-значення

3. Вузли представлені за допомогою кола, а відношення представлені за допомогою клавіш зі стрілками

4. Відношення мають напрямки: односпрямовані і двонаправлені

5. Кожне відношення містить «Початковий вузол» або «Від вузла» і «До вузла» або «Кінцевий вузол»

6. І Вузли і відношення містять властивості

7. Відношення пов'язують вузли

Модель такої БД схематично зображена на малюнку
![](../src/image/model.png)


! У Neo4j відношення повинні бути спрямованими. Якщо ми спробуємо створити відношення без направлення, Neo4j видасть повідомлення про помилку, в якому говориться, що «відношення повинні бути спрямованими».

! Neo4j Graph Database зберігає всі свої дані у вузлах і відношеннях. Нам не потрібна ні додаткова база даних RRBMS, ні база даних SQL для зберігання даних бази даних Neo4j. Він зберігає свої дані у вигляді графіків в своєму рідному форматі.

! Neo4j використовує Native GPE (Graph Processing Engine) для роботи з форматом зберігання Native Graph.

! Основними будівельними блоками моделі даних Graph DB є -

- вершини
- відношення
- властивості

Нижче наведено простий приклад графа властивостей.

![](../src/image/property_graph-1.png)
        
Тут ми представили вузли, використовуючи кола. Відношення представлені стрілками. Відношення є спрямованими. Ми можемо уявити дані вузла в термінах властивостей (пари ключ-значення). У цьому прикладі ми представили властивість Id кожного вузла в колі вузла.

## Neo4j - Будівельні блоки

Neo4j Graph Database має наступні будівельні блоки -

    вершини
    властивості
    відношення
    мітки
    браузер даних
    
#### Вузол

Вузол є фундаментальною одиницею Графа. Він містить властивості з парами ключ-значення, як показано на наступному малюнку.

![](../src/image/node-1.png)
    
Тут Node Name = "Employee», і він містить набір властивостей у вигляді пар ключ-значення.

##### Властивості

Властивість - це пара ключ-значення для опису вузлів і відношень графа.

    Key = Value 
    
Де Key - це String, а Value може бути представлено з використанням будь-яких типів даних Neo4j.

#### Відношення

Відношення є ще одним важливим будівельним блоком графічної бази даних. Воно з'єднуює два вузли, як показано на наступному малюнку.

![](../src/image/relationship-1.png)
    
Тут Emp і Dept - два різних вузла. «WORKS_FOR» - це відношення між вузлами Emp і Dept.

Кожне відношення містить один початковий вузол і один кінцевий вузол.
Тут «Emp» є початковим вузлом, а «Dept» є кінцевим вузлом.
Оскільки ця мітка стрілки відношень представляє відношення між вузлом «Emp» і вузлом «Dept», це відношення відомо як «Вхідні відношення» до вузла «Dept» і «Вихідні відношення» до вузла «Emp».

Як і вузли, відношення також можуть містити властивості у вигляді пар ключ-значення.

![](../src/image/properties-1.png)
    
Тут відношення «WORKS_FOR» має одну властивість як пара ключ-значення.

    ID = 123

Він являє собою ідентифікатор цих відношень.

#### Мітки

Мітка пов'язує спільне ім'я з набором вузлів або відношень. Вузол або відношення можуть містити одну або кілька міток. Ми можемо створити нові теги для існуючих вузлів або відношень. Ми можемо видалити існуючі мітки з існуючих вузлів або зв'язків.

З попередньої діаграми ми можемо спостерігати, що є два вузла.
Лівий боковий вузол має мітку: «Emp», а правий боковий вузол має мітку: «Dept».
Зв'язок між цими двома вузлами також має мітку: «WORKS_FOR».

Примітка. Neo4j зберігає дані у властивостях вузлів або відношень.

#### Neo4j Data Browser

Після інсталяції Neo4j ми можемо отримати доступ до Neo4j Data Browser, використовуючи наступний URL

    http://localhost:7474/browser/

![](../src/image/browser.png)

Neo4j Data Browser використовується для виконання команд CQL і перегляду вихідних даних.

Тут нам потрібно виконати всі команди CQL за підказкою долара: «$» . Введіть команди після символу долара і натисніть кнопку «Виконати» для запуску команд.

Він взаємодіє з сервером бази даних Neo4j, витягує і відображає результати прямо під підказкою долара.

## Neo4j CQL
CQL означає Cypher Query Language. Подібно до того, як Oracle Database має мову запитів SQL, Neo4j має CQL в якості мови запитів.
Neo4j CQL

- Мова запитів для Neo4j Graph Database.
- Це декларативна мова зіставлення зі зразком.
- Слідує SQL як синтаксис.
- Синтаксис дуже простий і зрозумілий людині.

#### Як Oracle SQL :

1. Neo4j CQL має команди для виконання операцій з базою даних.

2. Neo4j CQL підтримує безліч запитів, таких як WHERE, ORDER BY і т. Д., для простого написання дуже складних запитів.

3. Neo4j CQL підтримує деякі функції, такі як String, Aggregation. Додатково до них, він також підтримує деякі функції відношень.

#### Запити
###### Запити читання

| № | Запит | Використання |
| -- |:------------:| -------------------------------------:|
|1|MATCH|Цей запит використовується для пошуку даних із зазначеним шаблоном.|
|2|Optional MATCH| Це те ж саме, що і збіг, єдина відмінність полягає в тому, що він може використовувати нулі в разі відсутності частин шаблону. |
|3|WHERE|Цей ідентифікатор запиту використовується для додавання вмісту в запити CQL. |
|4|START|Цей запит використовується для пошуку відправних точок за застарілими індексами.|
|5|LOAD CSV|Цей запит використовується для імпорту даних з файлів CSV.|

###### Запити запису
| № | Запит | Використання |
| -- |:------------:| -------------------------------------:|
|1|Create|Цей запит використовується для створення вузлів, відношень і властивостей.|
|2|Merge|Цей пункт перевіряє, чи існує вказаний шаблон в графі. Якщо немає, то це створює шаблон.|
|3|Set|Цей пункт використовується для поновлення міток на вузлах, властивостей на вузлах і відношень.|
|4|Delete|Цей пункт використовується для видалення вузлів і відношень або шляхів і т. Д. З графа.|
|5|Remove|Цей запит використовується для видалення властивостей і елементів з вузлів і відношень.|
|6|Foreach|Цей клас використовується для поновлення даних в списку.|

###### Загальні запити
| № | запит | Використання |
| -- |:------------:| -------------------------------------:|
|1|Return|Цей запит використовується для визначення того, що включити в набір результатів запиту.|
|2|Order by|Цей запит використовується для впорядкування результатів запиту один по одному. Він використовується разом з пунктами RETURN або WITH.|
|3|Limit|Цей запит використовується для обмеження рядків в результаті певних значень.|
|4|Skip|Цей запит використовується для визначення, з якого рядка починати, включаючи рядки у висновку.|
|5|With|Цей запит використовується для об'єднання частин запиту.|
|6|Union|Цей пункт використовується для об'єднання результатів декількох запитів.|
|7|Using|Ви можете примусити Cypher використовувати конкретну точку відліку за допомогою запити USING. У цьому випадку говорять, що дали Cypher індексний хінт (рада).|

#### Neo4j CQL Функції 
Нижче наведені часто використовувані функції Neo4j CQL -
| № | CQL Функції | Використання |
| -- |:------------:| -------------------------------------:|
|1|строкові| Вони використовуються для роботи із строковими літералами.| Вони використовуються для виконання деяких операцій агрегування результатів CQL Query.
|2|агрегування| Вони використовуються для отримання деталей відношень, таких як початковий вузол, кінцевий вузол і т.д. |
|3|відношень|Вони використовуються для отримання деталей відношень, таких як початковий вузол, кінцевий вузол і т.д.|

## Neo4j CQL — Cтворення вузлів

Як вже говорилося, вузол - це дані / запис в графовой базі даних. Ви можете створити вузол в Neo4j, використовуючи запит CREATE.

#### Створення одного вузла

Ви можете створити вузол в Neo4j, просто вказавши ім'я вузла, який повинен бути створений, разом з запитом CREATE.
синтаксис

Нижче наведено синтаксис для створення вузла з використанням мови запитів Cypher.

```cypher
CREATE (node_name)
```

**Приклад 1**

Нижче наведено приклад Cypher Query, який створює вузол в Neo4j.

```cypher
CREATE (sample)
```
![](../src/image/example1.PNG)

Верифікація. Щоб перевірити створення типу вузла, виконайте наступний запит в підказці долара.

```cypher
 MATCH (n) RETURN n
```

Цей запит повертає всі вузли в базі даних

![](../src/image/example1_1.png)

#### Створення декількох вузлів

запит create в Neo4j CQL також використовується для створення декількох вузлів одночасно. Для цього необхідно передати імена створюваних вузлів через кому.
синтаксис

Нижче наведено синтаксис для створення декількох вузлів за допомогою запиту CREATE.

```cypher
CREATE (node1), (node2)
```

**Приклад 2**

Нижче наведено приклад Cypher Query, який створює кілька вузлів в Neo4j.

```cypher
CREATE (sample1), (sample2)
```

![](../src/image/example2.PNG)

#### Створення вузла з міткою

Мітка в Neo4j використовується для угруповання (класифікації) вузлів за допомогою міток. Ви можете створити мітку для вузла в Neo4j, використовуючи запит CREATE.

Нижче наведено синтаксис для створення вузла з міткою з використанням мови запитів Cypher.

```cypher
CREATE (node: label)
```

**Приклад 3**

Нижче наведено приклад Cypher Query, який створює вузол з міткою.

```cypher
CREATE (Dhawan: player)
```

![](../src/image/example3.PNG)

#### Створення вузла з декількома мітками

Ви також можете створити кілька міток для одного вузла. Вам необхідно вказати мітки для вузла, розділивши їх двокрапкою «:».
синтаксис

Нижче наведено синтаксис для створення вузла з декількома мітками.

```cypher
CREATE (node:label1:label2:....labeln)
```

**Приклад 4**

Нижче наведено приклад Cypher Query, який створює вузол з декількома мітками в Neo4j.

```cypher
CREATE (Dhawan:person:player)
```

![](../src/image/example4.PNG)

#### Створити вузол з властивостями

Властивості - це пари ключ-значення, за допомогою яких вузол зберігає дані. Ви можете створити вузол з властивостями, використовуючи запит CREATE. Вам необхідно вказати ці властивості через кому в квіткових дужках «{}».
синтаксис

Нижче наведено синтаксис для створення вузла з властивостями.

```cypher
CREATE (node: label {key1: value, key2: value,.........})
```

**Приклад 5**

Нижче наведено приклад Cypher Query, який створює вузол з властивостями.

```cypher
CREATE (Dhawan: player {name: "Shikar Dhawan", YOB: 1985, POB: "Delhi"})
```

![](../src/image/example5.PNG)

#### Повернення створеного вузла

Вже використовувався запит

```cypher
MATCH (n) RETURN n 
```
для перегляду створених вузлів. Цей запит повертає всі існуючі вузли в базі даних.Замість цього ми можемо використовувати запит RETURN з CREATE для перегляду новоствореного вузла.
синтаксис

Нижче наведено синтаксис для повернення вузла в Neo4j.

```cypher
CREATE (Node: Label {properties....}) RETURN Node
```

**Приклад 6**

Нижче наведено приклад Cypher Query, який створює вузол з властивостями і повертає його.

```cypher
CREATE (Dhawan: player {name: "Shikar Dhawan", YOB: 1985, POB: "Delhi"}) RETURN Dhawan
```

## Neo4j CQL - Створення відношень

У Noe4j відношення - це елемент, за допомогою якого ми з'єднуємо два вузла графа. Ці відношення мають напрямок, тип і шаблони даних. 

#### Cтворення відношень

Ми можемо створити відношень, використовуючи запит CREATE. Ми поставимо ставлення в квадратних дужках «[]» в залежності від напрямку відношень, яке воно поміщає між дефісом «-» і стрілкою «→», як показано в наступному синтаксисі.

Нижче наведено синтаксис для створення відношень з використанням запиту CREATE.

```cypher
CREATE (node1) - [: RelationshipType] -> (node2)
```

**Приклад 7**

Перш за все, створіть два вузла Ind і Dhawan в базі даних, як показано нижче.

```cypher
CREATE (Dhawan: player {name: "Shikar Dhawan", YOB: 1985, POB: "Delhi"})
CREATE (Ind: Country {name: "India"})
```

Тепер створіть зв'язок з ім'ям BATSMAN_OF між цими двома вузлами 

```cypher
CREATE (Dhawan) - [r: BATSMAN_OF] -> (Ind)
```

Нарешті, поверніть обидва вузла, щоб побачити створені відношення.

```cypher
RETURN Dhawan, Ind
```

![](../src/image/example7.PNG)

#### Створення зв'язку між існуючими вузлами

Ви також можете створити зв'язок між існуючими вузлами, використовуючи запит MATCH.
синтаксис
Нижче наведено синтаксис для створення відношень з використанням запиту MATCH.

```cypher
MATCH (a: LabeofNode1), (b: LabeofNode2)
WHERE a.name = "nameofnode1" AND b.name = "nameofnode2"
CREATE (a) - [: Relation] -> (b)
RETURN a, b
```

**Приклад 8**

Нижче наведено приклад Cypher Query, який створює відношення за допомогою запиту match.

```cypher
MATCH (a: player), (b: Country) WHERE a.name = "Shikar Dhawan" AND b.name = "India"
CREATE (a) - [r: BATSMAN_OF] -> (b)
RETURN a, b
```

![](../src/image/example8.PNG)

#### Створення відношень з міткою і властивостями

Ви можете створити відношення з міткою і властивостями, використовуючи запит CREATE.
синтаксис

Нижче наведено синтаксис для створення відношення з міткою і властивостями за допомогою запити CREATE.

```cypher
CREATE (node1) - [label: Rel_Type {key1: value1, key2: value2,. . . n}] -> (node2)
```

**Приклад 9**

Нижче наведено приклад Cypher Query, який створює відношення з міткою і властивостями.

```cypher
MATCH (a: player), (b: Country) WHERE a.name = "Shikar Dhawan" AND b.name = "India"
CREATE (a) - [r: BATSMAN_OF {Matches: 5, Avg: 90.75}] -> (b)
RETURN a, b
```

#### Створення повного шляху

У Neo4j шлях формується з використанням безперервних відношень. Шлях може бути створений за допомогою запиту create.

Нижче наведено синтаксис для створення шляху в Neo4j з використанням запиту CREATE.

```cypher
CREATE p = (Node1 {properties}) - [: Relationship_Type] ->
(Node2 {properties}) [: Relationship_Type] -> (Node3 {properties})
RETURN p
```

**Приклад 10**

```cypher
CREATE p = (Dhawan {name: "Shikar Dhawan"}) - [: TOP5SCORRER_OF] ->
(Ind {name: "India"})-[:WINNER_OF] -> (CT{name: "Champions Trophy 2021"})
RETURN p
```

![](../src/image/example10.PNG)

## Neo4j - запит MERGE 

Команда MERGE є комбінацією команди CREATE і команди MATCH.

Команда Neo4j CQL MERGE шукає заданий шаблон в графі. Якщо він існує, він повертає результати.

Якщо він НЕ існує в графі, то він створює новий вузол / відношення і повертає результати.

Нижче наведено синтаксис команди MERGE.

```cypher
MERGE (node: label {properties.......})
```

Перш ніж перейти до прикладів в цьому розділі, створимо два вузла в базі даних з мітками Dhawan і Ind. Створимо відношення типу «BATSMAN_OF» від Dhawan до Ind, як показано нижче.

```cypher
CREATE (Dhawan:player{name: "Shikar Dhawan", YOB: 1985, POB: "Delhi"}) 
CREATE (Ind:Country {name: "India"}) 
CREATE (Dhawan)-[r:BATSMAN_OF]->(Ind) 
```

#### Вивід вузла за міткою

Ви можете об'єднати вузол в базі даних на основі мітки, використовуючи запит MERGE. Якщо ви спробуєте об'єднати вузол на основі мітки, то Neo4j перевіряє, чи існує який-небудь вузол з даної міткою. Якщо немає, поточний вузол буде створений.

Нижче наведено синтаксис для об'єднання вузла на основі мітки.

```cypher
MERGE (node: label) RETURN node
```

**Приклад 11**

Нижче наведено приклад Cypher Query, який об'єднує вузол в Neo4j (на основі мітки). Коли ви виконуєте цей запит, Neo4j перевіряє, чи є який-небудь вузол з програвачем міток. Якщо немає, він створює вузол з ім'ям «Jadeja» і повертає його.

Якщо існує будь-який вузол з даної міткою, Neo4j повертає їх всі.

```cypher
MERGE (Jadeja: player) RETURN Jadeja
```

Виконавши, ви отримаєте наступний результат. Оскільки ви вже створили вузол з ім'ям «Dhawan» з міткою «player» в базі даних, Neo4j повертає його, як показано на наступному скріншоті.

![](../src/image/example11.PNG)

**Приклад 12**

Тепер об'єднаємо вузол з ім'ям «CT2013» з міткою «Tournament». Оскільки немає вузлів з цією міткою, Neo4j створює вузол з заданим ім'ям і повертає його.

```cypher
MERGE (CT2013: Tournament {name: "ICC Champions Trophy 2013"})
RETURN CT2013, labels (CT2013)
```

![](../src/image/example12.PNG)

Як вже говорилося, оскільки немає вузла з даною міткою (Tournament) Neo4j створює і повертає зазначений вузол, як показано на скріншоті.

#### Вивід вузла за властивістю

Також можна об'єднати вузол з набором властивостей. Якщо це зробити, Neo4j виконає пошук рівної відповідності для зазначеного вузла, включаючи властивості. Якщо він не знаходить, він створює.

Нижче наведено синтаксис для об'єднання вузла з використанням властивостей.

```cypher
MERGE (node: label {key1: value, key2: value, key3: value........})
```

**Приклад 13**

Нижче наведено приклад Cypher Query для об'єднання вузла з використанням властивостей. Цей запит намагається об'єднати вузол з ім'ям «jadeja», використовуючи властивості і мітку. Оскільки немає такого вузла з точною міткою і властивостями, Neo4j створює його.

```cypher
MERGE (Jadeja: player {name: "Ravindra Jadeja", YOB: 1988, POB: "NavagamGhed"})
RETURN Jadeja
```

Отримано наступний результат. Як вже говорилося, оскільки немає вузлів із зазначеними міткою і властивостями, він створює його, як показано на наступному скріншоті.

![](../src/image/example13.PNG)

#### OnCreate і OnMatch

Кожен раз, коли ми виконуємо запит на злиття, вузол або збігається, або створюється. Використовуючи on create і on match, ви можете встановити властивості для вказівки того, чи створений ввузол або чи відповідає.

Нижче наводиться синтаксис запитів OnCreate і OnMatch.

```cypher
MERGE (node: label {properties...........})
ON CREATE SET property.isCreated = "true"
ON MATCH SET property.isFound = "true"
```

**Приклад 14**

Нижче наведено приклад Cypher Query, який демонструє використання запитів OnCreate і OnMatch в Neo4j. Якщо вказаний вузол вже існує в базі даних, то вузол буде підтверджено, і в вузлі буде створено властивість з парою ключ-значення isFound = «true».

Якщо вказаний вузол не існує в базі даних, то вузол буде створений, і в ньому буде створено властивість з парою ключ-значення isCreated = «true».

```cypher
MERGE (Jadeja: player {name: "Ravindra Jadeja", YOB: 1988, POB: "NavagamGhed"})
ON CREATE SET Jadeja.isCreated = "true"
ON MATCH SET Jadeja.isFound = "true"
RETURN Jadeja
```

![](../src/image/example14.PNG)

Оскільки немає вузла із зазначеними деталями, Neo4j створив його разом з властивістю isFound, як показано на наступному скріншоті.

#### Об'єднання відношень

Як і над вузлами, ми також можемо виконувати дії над відношеннями, використовуючи запит MERGE.

**Приклад 15**

Нижче наведено приклад Cypher Query, який об'єднує відношень за допомогою запити MATCH в Neo4j. Цей запит намагається об'єднати ставлення з ім'ям WINNERS_OF між вузлами «ind» (мітка: країна і назва: Індія) і ICC13 (мітка: турнір і ім'я: ICC Champions Trophy 2013).

Оскільки такого відношення не існує, Neo4j створює його.

```cypher
MATCH (a: Country), (b: Tournament)
    WHERE a.name = "India" AND b.name = "ICC Champions Trophy 2013"
    MERGE (a) - [r: WINNERS_OF] -> (b)
RETURN a, b
```

![](../src/image/example15.PNG)

Оскільки вказане відношення не існує в базі даних, Neo4j створює його, як показано на скріншоті. 

## Neo4j - запит SET

Використовуючи запит Set, ми можемо додавати нові властивості в існуючий вузол або ставлення, а також додавати або оновлювати існуючі значення властивостей.

#### Встановлення властивості

Використовуючи запит SET, ви можете створити нову властивість в вузлі.

Нижче наведено синтаксис для установки властивості.

```cypher
MATCH (node: label {properties..............})
SET node.property = value
RETURN node
```

**Приклад 16**

Перш ніж приступити до прикладу, спочатку створимо вузол з ім'ям Dhawan, як показано нижче.

```cypher
CREATE (Dhawan: player {name: "shikar Dhawan", YOB: 1985, POB: "Delhi"})
```

Нижче наведено приклад Cypher Query для створення властивості з ім'ям «highestscore» зі значенням «187».

```cypher
MATCH (Dhawan: player {name: "shikar Dhawan", YOB: 1985, POB: "Delhi"})
SET Dhawan.highestscore = 187
RETURN Dhawan
```

![](../src/image/example16.PNG)

Тут ви можете бачити, що властивість з парою ключ-значення Highestscore = 187 створюється в вузлі з ім'ям «Dhawan».

#### Видалення властивості

Ви можете видалити існуюче властивість, передавши йому значення NULL. Нижче наведено синтаксис видалення властивості з вузла за допомогою запиту SET.

```cypher
MATCH (node: label {properties})
SET node.property = NULL
RETURN node
```

**Приклад 17**

Перш ніж приступити до прикладу, спочатку створимо вузол «jadeja», як показано нижче.

```cypher
CREATE (Jadeja: player {name: "Ravindra Jadeja", YOB: 1988, POB: "NavagamGhed"})
```

Нижче наведено приклад Cypher Query, який видаляє властивість з ім'ям POB з цього вузла за допомогою запиту SET, як показано нижче.

```cypher
MATCH (Jadeja: player {name: "Ravindra Jadeja", YOB: 1988, POB: "NavagamGhed"})
SET Jadeja.POB = NULL
RETURN Jadeja
```

Тут ви можете помітити, що змінна з ім'ям POB була видалена.

![](../src/image/example17.PNG)

#### Установка декількох властивостей

Таким же чином ви можете створити кілька властивостей в вузлі, використовуючи запит Set. Для цього вам потрібно вказати ці пари ключ-значення комами.

Нижче наведено синтаксис для створення декількох властивостей в вузлі за допомогою запиту SET.

```cypher
MATCH (node: label {properties})
SET node.property1 = value, node.property2 = value
RETURN node
```

**Приклад 18**

Нижче наведено приклад Cypher Query, який створює кілька властивостей в вузлі за допомогою запиту SET в Neo4j.

```cypher
MATCH (Jadeja: player {name: "Ravindra Jadeja", YOB: 1988})
SET Jadeja.POB = "NavagamGhed", Jadeja.HS = "90"
RETURN Jadeja
```

![](../src/image/example18.PNG)

Тут ви можете побачити, що були створені властивості з іменами POB і HS.

#### Установка мітки на вузлі

Ви можете встановити мітку для існуючого вузла, використовуючи запит SET.
Нижче наведено синтаксис для установки мітки для існуючого вузла.

```cypher
MATCH (n {properties.......})
SET n: label
RETURN n
```

**Приклад 19**

Перш ніж приступити до прикладу, спочатку створіть вузол «Anderson», як показано нижче.

```cypher
CREATE (Anderson {name: "James Anderson", YOB: 1982, POB: "Burnely"})
```

Нижче наведено приклад Cypher Query для установки мітки на вузлі за допомогою запиту SET. Цей запит додає мітку «player» до вузла Anderson і повертає його.

```cypher
MATCH (Anderson {name: "James Anderson", YOB: 1982, POB: "Burnely"})
SET Anderson: player
RETURN Anderson
```

![](../src/image/example19.PNG)

Тут ми можемо помітити, що мітка з ім'ям «player» додається до вузла.

#### Установка декількох міток на вузлі

Ви можете встановити кілька міток для існуючого вузла, використовуючи запит SET. Тут необхідно вказати мітки, розділяючи їх двокрапкою «:».
синтаксис

Нижче наведено синтаксис для установки декількох міток для існуючого вузла за допомогою запити SET.

```cypher
MATCH (n {properties.......})
SET n: label1: label2
RETURN n
```

**Приклад 20**

Перш ніж приступити до прикладу, спочатку створіть вузол з ім'ям «Ishant», як показано нижче.

```cypher
CREATE (Ishant {name: "Ishant Sharma", YOB: 1988, POB: "Delhi"})
```

Нижче наведено приклад Cypher Query, який використовується для створення декількох міток на вузлі за допомогою запиту SET.

```cypher
MATCH (Ishant {name: "Ishant Sharma", YOB: 1988, POB: "Delhi"})
SET Ishant: player: person
RETURN Ishant
```

## Neo4j - Видалення вузлів і відношень

Ви можете видалити вузли і зв'язку з бази даних, використовуючи запит DELETE.

#### Видалення всіх вузлів і відношень

Нижче наведено запит на видалення всіх вузлів і зв'язків в базі даних за допомогою запиту DELETE.
запит

```cypher
MATCH (n) DETACH DELETE n
```

#### Видалення певного вузла

Щоб видалити конкретний вузол, вам необхідно вказати деталі вузла замість «n» в наведеному вище запиті.

Нижче наведено синтаксис для видалення певного вузла з Neo4j за допомогою запиту DELETE.

```cypher
MATCH (node: label {properties..........})
DETACH DELETE node
```

**Приклад 21**

Перш ніж приступити до прикладу, створіть вузол «Ishant» в базі даних Neo4j, як показано нижче.

```cypher
CREATE (Ishant: player {name: "Ishant Sharma", YOB: 1988, POB: "Delhi"})
```

Нижче наведено приклад Cypher Query, який видаляє створений вище вузол за допомогою запиту DELETE.

```cypher
MATCH (Ishant: player {name: "Ishant Sharma", YOB: 1988, POB: "Delhi"})
DETACH DELETE Ishant
MATCH (n) RETURN n
```

![](../src/image/example21.PNG)

Ми можемо помітити, що вказаний вузол Ishant видалено.

## Neo4j - видалення властивостей і міток

запит REMOVE використовується для видалення властивостей і міток з елементів графа (вузлів або відношень).

Основна відмінність між запитами Neo4j CQL DELETE і REMOVE -

- Запит DELETE використовується для видалення вузлів і пов'язаних зв'язків.
- Запит REMOVE використовується для видалення міток і властивостей.

## Видалення властивості

Ви можете видалити властивість вузла, використовуючи MATCH разом з запитом REMOVE.
синтаксис

Нижче наведено синтаксис для видалення властивості вузла за допомогою запиту REMOVE.

```cypher
MATCH (node: label {properties.......})
REMOVE node.property
RETURN node
```

**Приклад 22**

Перш ніж приступити до прикладу, створіть вузол з ім'ям Dhoni, як показано нижче.

```cypher
CREATE (Dhoni: player {name: "MahendraSingh Dhoni", YOB: 1981, POB: "Ranchi"})
```

Нижче наведено приклад Cypher Query для видалення створеного вище вузла за допомогою запиту REMOVE.

```cypher
MATCH (Dhoni: player {name: "MahendraSingh Dhoni", YOB: 1981, POB: "Ranchi"})
REMOVE Dhoni.POB
RETURN Dhoni
```

#### Видалення мітки з вузла

Подібно властивості, ви також можете видалити мітку з існуючого вузла, використовуючи запит remove.

Нижче наведено синтаксис для видалення мітки з вузла.

```cypher
MATCH (node: label {properties...........})
REMOVE node: label
RETURN node
```

**Приклад 23**

Нижче наведено приклад Cypher Query для видалення мітки з існуючого вузла за допомогою запиту remove.

```cypher
MATCH (Dhoni: player {name: "MahendraSingh Dhoni", YOB: 1981, POB: "Ranchi"})
REMOVE Dhoni: player
RETURN Dhoni
```

#### Видалення декількох міток

Ви також можете видалити кілька міток з існуючого вузла.
Нижче наведено синтаксис для видалення декількох міток з вузла.

```cypher
MATCH (node: label1: label2 {properties........})
REMOVE node: label1: label2
RETURN node
```

**Приклад 24**

Перш ніж приступити до прикладу, створіть вузол Ishant, як показано нижче.

```cypher
CREATE (Ishant: player: person {name: "Ishant Sharma", YOB: 1988, POB: "Delhi"})
```

Нижче наведено приклад Cypher Query для видалення декількох міток з вузла.

```cypher
MATCH (Ishant: player: person {name: "Ishant Sharma", YOB: 1988, POB: "Delhi"})
REMOVE Ishant: player: person
RETURN Ishant
```

## Neo4j - запит Foreach

Запит FOREACH використовується для поновлення даних в списку, будь то компоненти шляху або результат агрегації.

Нижче наведено синтаксис запиту FOREACH.

```cypher
MATCH p = (start node) - [*] -> (end node)
WHERE start.node = "node_name" AND end.node = "node_name"
FOREACH (n IN nodes (p) | SET n.marked = TRUE)
```

**Приклад 25**

Перш ніж приступити до прикладу, створіть шлях p в базі даних Neo4j, як показано нижче.

```cypher
CREATE p = (Dhawan {name: "Shikar Dhawan"}) - [: TOPSCORRER_OF] -> (Ind {name:
"India"}) - [: WINNER_OF] -> (CT2013 {name: "Champions Trophy 2013"})
RETURN p
```

Нижче наведено приклад Cypher Query, який додає властивість до всіх вузлів на шляху, використовуючи запит FOREACH.

```cypher
MATCH p = (Dhawan) - [*] -> (CT2013)
    WHERE Dhawan.name = "Shikar Dhawan" AND CT2013.name = "Champions Trophy 2013"
FOREACH (n IN nodes (p) | SET n.marked = TRUE)
```

![](../src/image/example25.PNG)

## Neo4j - MATCH-запит

Отримати всі вузли використовуючи Match

За допомогою запиту MATCH Neo4j ви можете отримати всі вузли в базі даних Neo4j.

**Приклад 26**

Перш ніж приступити до прикладу, створимо 3 вузли і 2 взаємозв'язки, як показано нижче.

```cypher
CREATE (Dhoni: player {name: "MahendraSingh Dhoni", YOB: 1981, POB: "Ranchi"})
CREATE (Ind: Country {name: "India", result: "Winners"})
CREATE (CT2013: Tornament {name: "ICC Champions Trophy 2013"})
CREATE (Ind) - [r1: WINNERS_OF {NRR: 0.938, pts: 6}] -> (CT2013)


CREATE (Dhoni) - [r2: CAPTAIN_OF] -> (Ind)
CREATE (Dhawan: player {name: "shikar Dhawan", YOB: 1995, POB: "Delhi"})
CREATE (Jadeja: player {name: "Ravindra Jadeja", YOB: 1988, POB: "NavagamGhed"})

CREATE (Dhawan) - [: TOP_SCORER_OF {Runs: 363}] -> (Ind)
CREATE (Jadeja) - [: HIGHEST_WICKET_TAKER_OF {Wickets: 12}] -> (Ind)
```  

Нижче наведено запит, який повертає всі вузли в базі даних Neo4j.

```cypher
MATCH (n) RETURN n
```

![](../src/image/example26.PNG)

#### Отримання всіх вузлів під певною міткою

Використовуючи запит відповідності, ви можете отримати всі вузли під певною міткою.
синтаксис

Нижче наведено синтаксис для отримання всіх вузлів під певною міткою.

```cypher
MATCH (node: label)
RETURN node
```

**Приклад 27**

Нижче наведено приклад Cypher Query, який повертає всі вузли в базі даних під програвачем міток.

```cypher
MATCH (n: player)
RETURN n
```

![](../src/image/example27.PNG)

#### MATCH за співвідношенням

Ви можете отримати вузли на основі відношень, використовуючи запит MATCH.

Нижче наведено синтаксис отримання вузлів на основі відношень з використанням запиту MATCH.

```cypher
MATCH (node: label) <- [: Relationship] - (n)
RETURN n
```

**Приклад 28**

Нижче наведено приклад Cypher Query для вилучення вузлів на основі відношень з використанням запиту MATCH.

```cypher
MATCH (Ind: Country {name: "India", result: "Winners"}) <- [: TOP_SCORER_OF] - (n)
RETURN n.name
```

![](../src/image/example28.PNG)

#### Видалити всі вузли

Ви можете видалити всі вузли, використовуючи запит MATCH
запит.
Нижче наведено запит на видалення всіх вузлів в Neo4j.

```cypher
MATCH (n) detach delete n
```

## Neo4j -  запит OPTIONAL MATCH

Запит OPTIONAL MATCH використовується для пошуку шаблону, описаного в ньому, при використанні нулів для відсутніх частин шаблону.

OPTIONAL MATCH аналогічний запиту match, єдина відмінність полягає в тому, що він повертає нуль в результаті пропущених частин шаблону.

Нижче наводиться синтаксис функціонального MATCH з відношенням.

```cypher
MATCH (node: label {properties..............})
OPTIONAL MATCH (node) -> (x)
RETURN x
```

**Приклад 29**

Нижче наведено приклад Cypher Query, який намагається витягти відношення з вузла ICCT2013. Оскільки таких вузлів немає, повертається нуль.

```cypher
MATCH (a: Tornament {name: "ICC Champions Trophy 2013"})
OPTIONAL MATCH (a) --> (x)
RETURN x
```

![](../src/image/example29.PNG)

Тут ви можете помітити, що, оскільки для необхідного шаблону немає збігів, Neo4j повернув нуль.

**Приклад 30**

```cypher
MATCH (a: player {name:"shikar Dhawan"})
OPTIONAL MATCH (a) --> (x)
RETURN x
```

![](../src/image/example30.PNG)

## Neo4j - запит WHERE

Як і SQL, Neo4j CQL надав запит WHERE в команді CQL MATCH для фільтрації результатів запиту MATCH.

Нижче наведено синтаксис запиту WHERE.

```cypher
MATCH (label)
WHERE label.country = "property"
RETURN label
```

**Приклад 31**

Перш ніж приступити до прикладу, створіть п'ять вузлів в базі даних, як показано нижче.

```cypher
CREATE (Dhawan: player {name: "shikar Dhawan", YOB: 1985, runs: 363, country: "India"}
CREATE (Jonathan: player {name: "Jonathan Trott", YOB: 1981, runs: 229, country: "South Africa"}
CREATE (Sangakkara: player {name: "Kumar Sangakkara", YOB: 1977, runs: 222,
country: "Srilanka"})
CREATE (Rohit: player {name: "Rohit Sharma", YOB: 1987, runs: 177, country: "India"})
CREATE (Virat: player {name: "Virat Kohli", YOB: 1988, runs: 176, country: "India"})
CREATE (Ind: Country {name: "India", result: "Winners"})
```

Нижче наведено приклад Cypher Query, який повертає всіх гравців (вузлів), що належать країні Індія, з використанням запиту WHERE.

```cypher
MATCH (player)
WHERE player.country = "India"
RETURN player
```

![](../src/image/example31.PNG)

#### запит WHERE з декількома умовами

Ви також можете використовувати запит WHERE для перевірки декількох умов.

Нижче наводиться синтаксис використання запиту WHERE в Neo4j з декількома умовами.

```cypher
MATCH (emp: Employee)
WHERE emp.name = 'Abc' AND emp.name = 'Xyz'
RETURN emp
```

**Приклад 32**

Нижче наведено приклад Cypher Query, який фільтрує вузли в базі даних Neo4j, використовуючи дві умови.

```cypher
MATCH (player)
WHERE player.country = "India" AND player.runs> = 175
RETURN player
```

![](../src/image/example32.PNG)

#### Neo4j - функція підрахунку

Створимо графік в базі даних з наступними деталями.
 
```cypher
CREATE (Dhoni: player {name: "MahendraSingh Dhoni", YOB: 1981, POB: "Ranchi"})
CREATE (Ind: Country {name: "India", result: "Winners"})
CREATE (CT2013: Tornament {name: "ICC Champions Trophy 2013"})
CREATE (Ind) - [r1: WINNERS_OF {NRR: 0.938, pts: 6}] -> (CT2013)


CREATE (Dhoni) - [r2: CAPTAIN_OF] -> (Ind)
CREATE (Dhoni) - [r3: WICKET_KEEPER] -> (Ind)
CREATE (Dhawan: player {name: "shikar Dhawan", YOB: 1995, POB: "Delhi"})
CREATE (Jadeja: player {name: "Ravindra Jadeja", YOB: 1988, POB: "NavagamGhed"})

CREATE (Dhawan) - [: TOP_SCORER_OF {Runs: 363}] -> (Ind)
CREATE (Jadeja) - [: HIGHEST_WICKET_TAKER_OF {Wickets: 12}] -> (Ind)
CREATE (Rohit: player {name: "Rohit Sharma", YOB: 1987, runs: 177, country: "India"})
CREATE (Virat: player {name: "Virat Kohli", YOB: 1988, runs: 176, country: "India"})
CREATE (Rohit) - [r4: BATSMAN_OF] -> (Ind)
CREATE (Virat) - [r5: BATSMAN_OF] -> (Ind)

CREATE (Jonathan: player {name: "Jonathan Trott", YOB: 1981, runs: 229, country: "South Africa"})
    
CREATE (Sangakkara: player {name: "Kumar Sangakkara", YOB: 1977, runs: 222, country: "Srilanka"})
    
CREATE (Jonathan) - [r6: BOWLER_OF] -> (Ind)
CREATE (Sangakkara) - [r7: BOWLER_OF] -> (Ind)
```

Функція count () використовується для підрахунку кількості рядків.

Нижче наводиться синтаксис функції count.

```cypher
MATCH (n {name: 'A'}) -> (x)
RETURN n, count (*)
```

**Приклад 34**

Нижче наведено приклад Cypher Query, який демонструє використання функції count ().

```cypher
Match (n {name: "India", result: "Winners"}) -- (x)
RETURN n, count (*)
```

![](../src/image/example34.PNG)

## Neo4j - запит RETURN

запит RETURN використовується для повернення вузлів, відношень і властивостей в Neo4j. 

#### Повернення вузлів

Ви можете повернути вузол, використовуючи запит RETURN.
синтаксис.
Нижче наведено синтаксис для повернення вузлів за допомогою запиту RETURN.

```cypher
Create (node: label {properties})
RETURN node
```

**Приклад 35**

Перш ніж приступити до прикладу, створимо 3 вузли і 2 взаємозв'язки, як показано нижче.

```cypher
Create (Dhoni: player {name: "MahendraSingh Dhoni", YOB: 1981, POB: "Ranchi"})
CREATE (Ind: Country {name: "India", result: "Winners"})
CREATE (CT2013: Tornament {name: "ICC Champions Trophy 2013"})
CREATE (Ind) - [r1: WINNERS_OF {NRR: 0.938, pts: 6}] -> (CT2013)
CREATE (Dhoni) - [r2: CAPTAIN_OF] -> (Ind)
```

Нижче наведено приклад Cypher Query, який створює вузол з ім'ям Dhoni і повертає його.

```cypher
Create (Dhoni: player {name: "MahendraSingh Dhoni", YOB: 1981, POB: "Ranchi"})
RETURN Dhoni
```

#### Повернення декількох вузлів

Ви також можете повернути кілька вузлів, використовуючи запит return.
Нижче наведено синтаксис для повернення декількох вузлів за допомогою запиту return.

```cypher
CREATE (Ind: Country {name: "India", result: "Winners"})
CREATE (CT2013: Tornament {name: "ICC Champions Trophy 2013"})
RETURN Ind, CT2013
```

**Приклад 36**

Нижче наведено приклад Cypher Query для повернення декількох вузлів за допомогою запиту return.

```cypher
CREATE (Ind: Country {name: "India", result: "Winners"})
CREATE (CT2013: Tornament {name: "ICC Champions Trophy 2013"})
RETURN Ind, CT2013
```

#### Повернення відношень

Ви також можете повернути відношення, використовуючи запит Return.
Нижче наведено синтаксис для повернення відношень з використанням запити RETURN.

```cypher
CREATE (node1) - [Relationship: Relationship_type] -> (node2)
RETURN Relationship
```

**Приклад 37**

Нижче наведено приклад Cypher Query, який створює дві зв'язку і повертає їх.

```cypher
CREATE (Ind) - [r1: WINNERS_OF {NRR: 0.938, pts: 6}] -> (CT2013)
CREATE (Dhoni) - [r2: CAPTAIN_OF] -> (Ind)
RETURN r1, r2
```

![](../src/image/example37.PNG)

#### Повернення властивостей

Ви також можете повернути властивості, використовуючи запит RETURN.

Нижче наведено синтаксис для повернення властивостей з використанням запиту RETURN.

```cypher
Match (node: label {properties..........})
Return node.property
```

**Приклад 38**

Нижче наведено приклад Cypher Query для повернення властивостей вузла.

```cypher
Match (Dhoni: player {name: "MahendraSingh Dhoni", YOB: 1981, POB: "Ranchi"})
Return Dhoni.name, Dhoni.POB
```

![](../src/image/example38.png)

#### Повернення всіх елементів

Ви можете повернути всі елементи в базі даних Neo4j, використовуючи запит RETURN.

**Приклад 39**

Нижче наведено приклад Cypher Query для повернення всіх елементів в базі даних.

```cypher
Match p = (n {name: "India", result: "Winners"}) - [r] - (x)
RETURN *
```

#### Повернення властивості з псевдонімом 

Ви можете повернути певний стовпець з псевдонімом, використовуючи запит RETURN в Neo4j.

**Приклад 40**

Нижче наведено приклад Cypher Query, який повертає стовпець POB як Місце народження.

```cypher
Match (Dhoni: player {name: "MahendraSingh Dhoni", YOB: 1981, POB: "Ranchi"})
Return Dhoni.POB as Place_Of_Birth
```

![](../src/image/example40.PNG)

## Neo4j - впорядковування даних

Ви можете впорядкувати дані результатів по порядку, використовуючи запит ORDER BY
Нижче наведено синтаксис запиту ORDER BY.

```cypher
MATCH (n)
RETURN n.property1, n.property2. . . . . . . .
ORDER BY n.property
```

**Приклад 41**

Перш ніж приступити до прикладу, створіть 5 вузлів в базі даних Neo4j, як показано нижче.

```cypher
CREATE (Dhawan: player {name: "shikar Dhawan", YOB: 1985, runs: 363, country: "India"})
CREATE (Jonathan: player {name: "Jonathan Trott", YOB: 1981, runs: 229, country: "South Africa"})
CREATE (Sangakkara: player {name: "Kumar Sangakkara", YOB: 1977, runs: 222, country: "Srilanka"})
CREATE (Rohit: player {name: "Rohit Sharma", YOB: 1987, runs: 177, country: "India"})
CREATE (Virat: player {name: "Virat Kohli", YOB: 1988, runs: 176, country: "India"})
```

Нижче наведено приклад Cypher Query, який повертає створені вище вузли в порядку забігів гравця за допомогою запиту ORDERBY.

```cypher
MATCH (n)
RETURN n.name, n.runs
ORDER BY n.runs
```

![](../src/image/example41.PNG)

#### Впорядкування вузлів за кількома властивостями

Ви можете розташувати вузли на основі декількох властивостей, використовуючи запит ORDEYBY.

Нижче наведено синтаксис для розміщення вузлів по декільком властивостям з використанням запиту ORDERBY.

```cypher
MATCH (n)
RETURN n
ORDER BY n.age, n.name
```

**Приклад 42**

Нижче наведено приклад Cypher Query, який впорядковує вузли, створені раніше в цьому розділі, на основі властивостей - забігів і країни.

```cypher
MATCH (n)
RETURN n.name, n.runs, n.country
ORDER BY n.runs, n.country
```

![](../src/image/example42.PNG)

#### Впорядкування вузлів по спадаючій

Ви можете розташувати вузли в базі даних в порядку убування, використовуючи запит ORDERBY.
Нижче наведено синтаксис для розміщення вузлів в базі даних.

```cypher
MATCH (n)
RETURN n
ORDER BY n.name DESC
```

**Приклад 43**

Нижче наведено приклад Cypher Query, який впорядковує вузли в базі даних в порядку убування з використанням запиту ORDERBY.

```cypher
MATCH (n)
RETURN n.name, n.runs
ORDER BY n.runs DESC
```

## Neo4j - запит LIMIT

Запит limit використовується для обмеження кількості рядків у висновку.

Нижче наведено синтаксис запиту LIMIT.

```cypher
MATCH (n)
RETURN n
ORDER BY n.name
LIMIT 3
```

**Приклад 44**

Перш ніж приступити до прикладу, створіть 5 вузлів в базі даних Neo4j, як показано нижче.

```cypher
CREATE (Dhawan: player {name: "shikar Dhawan", YOB: 1985, runs: 363, country: "India"})
CREATE (Jonathan: player {name: "Jonathan Trott", YOB: 1981, runs: 229, country: "South Africa"})
CREATE (Sangakkara: player {name: "Kumar Sangakkara", YOB: 1977, runs: 222, country: "Srilanka"})
CREATE (Rohit: player {name: "Rohit Sharma", YOB: 1987, runs: 177, country: "India"})
CREATE (Virat: player {name: "Virat Kohli", YOB: 1988, runs: 176, country: "India"})

Нижче наведено приклад Cypher Query, який повертає створені вище вузли в порядку убування і обмежує записи в результаті до 3.
```

```cypher
MATCH (n)
RETURN n.name, n.runs
ORDER BY n.runs DESC
LIMIT 3
```

![](../src/image/example43.PNG)

#### LIMIT з виразом

Ви також можете використовувати запит LIMIT з виразом.

**Приклад 45**

Нижче наведено приклад Cypher Query, який обмежує записи за допомогою виразу.

```cypher
MATCH (n)
RETURN n.name, n.runs
ORDER BY n.runs DESC
LIMIT toInteger(3 * rand ()) + 1
```

![](../src/image/example45.PNG)


## Neo4j — запит SKIP

Запит SKIP використовується для визначення, з якого рядка починати, включаючи рядки у висновку.

**Приклад 46**

Перш ніж приступити до прикладу, створіть 5 вузлів, як показано нижче.

```cypher
CREATE (Dhawan: player {name: "shikar Dhawan", YOB: 1985, runs: 363, country: "India"})
CREATE (Jonathan: player {name: "Jonathan Trott", YOB: 1981, runs: 229, country: "South Africa"})
CREATE (Sangakkara: player {name: "Kumar Sangakkara", YOB: 1977, runs: 222, country: "Srilanka"})
CREATE (Rohit: player {name: "Rohit Sharma", YOB: 1987, runs: 177, country: "India"})
CREATE (Virat: player {name: "Virat Kohli", YOB: 1988, runs: 176, country: "India"})
```

Нижче наведено приклад Cypher Query, який повертає всі вузли в базі даних, пропускаючи перші 3 вузли.

```cypher
MATCH (n)
RETURN n.name, n.runs
ORDER BY n.runs DESC
SKIP 3
```

#### SKIP використовуючи вираз

Ви можете пропустити записи результату, використовуючи вираз.

**Приклад 46**

Нижче наведено приклад Cypher Query, в якому використовується вираз SKIP з виразом.

```cypher
MATCH (n)
RETURN n.name, n.runs
ORDER BY n.runs DESC
SKIP toInt (2 * rand ()) + 1
```

## Neo4j - запит WITH

Ви можете пов'язати запити разом, використовуючи запит WITH.
Нижче наведено синтаксис запиту WITH.

```cypher
MATCH (n)
WITH n
ORDER BY n.property
RETURN collect (n.property)
```

**Приклад 47**

Нижче наведено приклад Cypher Query, який демонструє використання запиту WITH.

```cypher
MATCH (n)
WITH n
ORDER BY n.name DESC LIMIT 3
RETURN collect (n.name)
```

![](../src/image/example47.PNG)

## Neo4j — запит UNWIND

Запит unwind використовується для розкручування списку в послідовність рядків.

**Приклад 48**

Ниже приведен пример Cypher Query, который раскручивает список.

```cypher 
UNWIND [a, b, c, d] AS x 
RETURN x 
```

## Neo4j - Функції

Як і SQL, Neo4J CQL надає набір функцій String для використання їх в запитах CQL для отримання необхідних результатів.

Список строкових функцій.
Нижче наведено список відомих функцій String в Neo4j.

| № | Строкові Функції | Використання |
| -- |:------------:| -------------------------------------:|
|1|STR|STR повертає строкове представлення виразу.|
|2|REPLACE|REPLACE повертає рядок, в якому рядок search замінюється на рядок replace. Заміна відбувається для всіх входжень рядка.|
|3|SUBSTRING|SUBSTRING повертає підрядок довжиною length з початкового рядка, починаючи з позиції start (відраховується від 0). Якщо довжина опущена, повертає підрядок від початкової позиції (start) до кінця рядка.|
|4|LEFT|LEFT повертає рядок, що містить n символів зліва початкового рядка.|
|5|RIGHT|RIGHT повертає рядок, що містить n символів праворуч початкового рядка.|
|6|LTRIM|LTRIM повертає вихідний рядок з виддаленими пробілами зліва.|
|7|RTRIM|RTRIM повертає вихідний рядок з видаленими пробілами справа.|
|8|TRIM|TRIM повертає вихідний рядок з видаленими пробілами з обох кінців рядка.|
|9|LOWER|LOWER повертає вихідний рядок в нижньому регістрі.|
|10|UPPER|UPPER повертає вихідний рядок у верхньому регістрі.|

Список строкових функцій.
Нижче наведено список відомих функцій колекцій в Neo4j.

| № | Функції Колекції | Використання |
| -- |:------------:| -------------------------------------:|
|1|NODES|Повертає всі вузли на шляху.|
|2|RELATIONSHIPS|Повертає всі зв'язки на шляху.|
|3|LABELS|Повертає колекцію строкових міток, приписаних вузлу.|
|4|EXTRACT|Щоб повернути єдину властивість або значення функції з колекції вузлів або зв'язків.|
|5|FILTER|FILTER повертає всі елементи в колекції, які узгоджуються з предикатом.|
|6|TAIL|TAIL повертає всі елементи в колекції крім першого.|
|7|RANGE|Повертає числові значення в діапазоні з ненульовим значення кроку step. Діапазон включає обидві границі.|
|8|REDUCE|Використовується для виконання виразу на окремих елементах колекції і зберігання результату виразу в накопичувачі|

## Neo4j - Індекси

Neo4j CQL підтримує індекси на властивостях вузлів або відношень для підвищення продуктивності додатка. Ми можемо створювати індекси за властивостями для всіх вузлів, які мають однакове ім'я мітки.

Ми можемо використовувати ці проіндексовані стовпці в операторі MATCH, WHERE або IN, щоб поліпшити виконання команди CQL.

#### Створення індексу

Neo4j CQL надає команду «CREATE INDEX» для створення індексів на властивостях Node або Relationship.
синтаксис

Нижче наведено синтаксис для створення індексу в Neo4j.

```cypher
CREATE INDEX ON: label (node)
```

**Приклад 49**

Перш ніж приступити до прикладу, створіть вузол Dhawan, як показано нижче.

```cypher
CREATE (Dhawan: player {name: "shikar Dhawan", YOB: 1995, POB: "Delhi"})
```

Нижче наведено приклад Cypher Query для створення індексу на вузлі Dhawan в Neo4j.

```cypher
CREATE INDEX ON: player (Dhawan)
```

#### Neo4j - CQL CREATE

У базі даних Neo4j команда CQL CREATE завжди створює новий вузол або ставлення, що означає, що, навіть якщо ви використовуєте ті ж значення, вона вставляє новий рядок. Відповідно до вимог нашого застосування для деяких вузлів або відношень, ми повинні уникати цього дублювання. Для цього ми повинні використовувати деякі обмеження бази даних, щоб створити правило для одного або декількох властивостей вузла або відношень.

Як і SQL, база даних Neo4j також підтримує унікальне обмеження на властивості вузла або відношень. Унікальне обмеження використовується, щоб уникнути дублювання записів і забезпечити дотримання правила цілісності даних.

Neo4j CQL надає команду «CREATE CONSTRAINT» для створення унікальних обмежень на властивості вузла або відношень.

Нижче наведено синтаксис для створення унікального обмеження в Neo4j.

```cypher
MATCH (root {name: "Dhawan"})
CREATE UNIQUE (root) - [: LOVES] - (someone)
RETURN someone
```

**Приклад 50**

Перш ніж приступити до прикладу, створіть 4 вузли, як показано нижче.

```cypher
CREATE (Dhawan: player {id: 001, name: "shikar Dhawan", YOB: 1995, POB: "Delhi"})
CREATE (Jonathan: player {id: 002, name: "Jonathan Trott", YOB: 1981, POB: "CapeTown"})
CREATE (Sangakkara: player {id: 003, name: "Kumar Sangakkara", YOB: 1977, POB: "Matale"})
CREATE (Rohit: player {id: 004, name: "Rohit Sharma", YOB: 1987, POB: "Nagpur"})
CREATE (Virat: player {id: 005, name: "Virat Kohli", YOB: 1988, POB: "Delhi"})
```

Нижче наведено приклад Cypher Query для створення унікального обмеження на ідентифікатор властивості за допомогою Neo4j.

```cypher
CREATE CONSTRAINT ON (n: player) ASSERT n.id IS UNIQUE
```

## Neo4j - DROP CONSTRAINT

Ми вже обговорювали створення УНІКАЛЬНИХ операцій з обмеженнями на прикладах в попередньому розділі. У цьому розділі ми обговоримо виключення операції УНІКАЛЬНА обмеження з прикладами.

Neo4j CQL надає команду «DROP CONSTRAINT» для видалення існуючого обмеження Unique з властивості вузла або відношень.
синтаксис

Нижче наводиться синтаксис для відкидання обмеження UNIQUE в Neo4j.

```cypher
DROP CONSTRAINT ON (node: label)
ASSERT node.id IS UNIQUE
```

**Приклад 51**

Нижче наведено приклад запиту Cypher для видалення обмеження UNIQUE для ідентифікатора властивості.

```cypher
DROP CONSTRAINT ON (n: player)
ASSERT n.id IS UNIQUE
```

## Neo4j - Використання стандартної БД movies

![](../src/image/movies_all.PNG)

Задачі

#### 1. Вивід властивостей

У кожної з нод у нас може бути безліч властивостей, але ми можемо отримати тільки те, що нам потрібно.

Наприклад:

```cypher
MATCH (g)-[k]->(n:Movie {title:"The Matrix"}) RETURN n.released,g.born,k;
```

![](../src/image/movies1.PNG)

Цей запит поверне дати народження акторів і дати випуску фільму.

#### 2. Пошук підграфу

Дуже часто в роботі з графовими базами даних треба користуватися можливістю пошуку подграфа.

Наприклад:

```cypher
MATCH (n: Movie { title: "The Matrix" })<-[k]-(g)-[l]->(s) return l,s,n,k,g;
```

![](../src/image/movies2.PNG)

Цей запит виведе пов'язані з нашим вузлом вузли, і вузли пов'язані з цими вузлами

#### 3. Пошук найкоротшого шляху

Одна з особливостей мови Cypher - це функція, яка дозволяє знайти найкоротший шлях з точки зору кількості зв'язків між двома вершинами.

Використовуючи граф фільму, який можна імпортувати за допомогою команди :play movies в браузері, створимо відношення «KNOWS» між людьми, які з'являлися в одному фільмі:

```cypher
MATCH (p1:Person)-[:ACTED_IN]->()<-[:ACTED_IN]-(p2:Person)
MERGE (p1)-[:KNOWS]-(p2)
```

Тепер, коли у нас є ці зв'язки, ми можемо легко знайти найкоротший шлях між двома людьми, скажімо, Томом Крузом і Томом Хенксом:

```cypher
MATCH (p1:Person {name: "Tom Hanks"}), (p2:Person {name: "Tom Cruise"}),
    path = shortestpath((p1)-[:KNOWS*]-(p2))
RETURN path
```

![](../src/image/movies3.PNG)

## Інформативні джерела 

[Graph Databases](https://neo4j.com/neoassets/graphbooks/Graph_Databases_2e_Neo4j.pdf)

[Neo4j Documentation ](https://neo4j.com/docs/)

---

## Матеріал підготував 

студент групи ІО-92 Іванов Родіон - [Rodionich](https://github.com/Rodionich)